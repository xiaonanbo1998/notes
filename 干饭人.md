# 零、表情符号

- :book:查询
- :star2:重要部分

# 附录、数据请求

1. 走接口
   - 路径和参数之间，直接【?id=1】
   - 路径最后，不需要【/】
2. 走模型
   - 路径和参数之间，间隔【/?id=1】
   - 路径最后，需要【/】
3. 其他
   - put数据的时候，表格不需要【s】
   - 外键，作为字段名的时候，加上【_id】

# 一、filter()函数

1. 返回通过测试的元素的新数组，返回数组可能为空

2. 其中一种写法

   ```javascript
   function isBigEnough(element) {
       return element > 10
   }
   let arr = [12, 5, 8, 130].filter(isBigEnough)
   ```

# 二、map()函数

1. 返回通过处理的元素的新数组

2. 可以返回undefined，空数组不执行，离散数组也执行，不改变原数组

3. 特殊注意

   ```javascript
   ["1", "2", "3"].map(parseInt)	//	实际结果是[1, NaN, NaN]
   // parseInt(string, radix) -> map(parseInt(value, index))
   /*  first iteration (index is 0): */ parseInt("1", 0); // 1
   /* second iteration (index is 1): */ parseInt("2", 1); // NaN
   /*  third iteration (index is 2): */ parseInt("3", 2); // NaN
   ['1', '2', '3'].map(item => parseInt(item))		//	[1, 2, 3]
   parseInt('a', 16)				//	10
   parseInt('11', 8)				//	9
   ```

# 三、String.slice()函数，Array.slice()函数

1. 返回从开始（包括开始）到结束的浅拷贝的新数组

2. 可以传入负数

   ```javascript
   let str = 'abcd'
   console.log(str.slice(0, 3))			//	abc
   console.log(str.slice(-2))				//	cd
   
   let array = ['ant', 'bison', 'camel', 'duck', 'elephant']
   console.log(array.slice(2))				//	camel, duck, elephant
   console.log(array.slice(2, 4))			//	camel, duck
   console.log(array.slice(-2))			//	duck, elephant
   ```
   
   

# 四、Array.splice()函数

1. 格式：array.splice(start[, deleteCount[, item1[, item2[, ...]]]])

2. 删除或替换现有元素，修改数组，返回被删除元素/空数组

3. 案例

   ```javascript
   var myFish = ['angel', 'clown', 'mandarin', 'sturgeon'];
   var removed = myFish.splice(2, 0, 'drum', 'guitar');
   
   // 运算后的 myFish: ["angel", "clown", "drum", "guitar", "mandarin", "sturgeon"]
   // 被删除的元素: [], 没有元素被删除
   
   
   var myFish = ['angel', 'clown', 'mandarin', 'sturgeon'];
   var removed = myFish.splice(-2, 1);
   
   // 运算后的 myFish: ["angel", "clown", "sturgeon"]
   // 被删除的元素: ["mandarin"]
   ```

   

# 五、call()函数

1. 使用this和一个/多个参数调用一个函数

2. 返回被调用函数的返回值，没有则返回undefined

3. 关于this的理解

   ```javascript
   function greet() {
     var reply = [this.animal, 'typically sleep between', this.sleepDuration].join(' ');
     console.log(reply);
   }
   
   var obj = {
     animal: 'cats', sleepDuration: '12 and 16 hours'
   };
   
   greet.call(obj);  // cats typically sleep between 12 and 16 hours
   
   ```

4. 类似apply()函数，call函数接收参数序列，apply函数接收数组

   ```javascript
   var array = ['a', 'b'];
   var elements = [0, 1, 2];
   array.push.apply(array, elements);
   console.info(array); // ["a", "b", 0, 1, 2]
   ```

   

# 六、Object.keys()函数

1. 返回一个可枚举对象组成的数组

2. 特别注意

   ```javascript
   // simple array
   var arr = ['a', 'b', 'c'];
   console.log(Object.keys(arr)); // console: ['0', '1', '2']
   
   // array like object
   var obj = { 0: 'a', 1: 'b', 2: 'c' };
   console.log(Object.keys(obj)); // console: ['0', '1', '2']
   
   // array like object with random key ordering
   var anObj = { 100: 'a', 2: 'b', 7: 'c' };
   console.log(Object.keys(anObj)); // console: ['2', '7', '100']
   
   // getFoo is a property which isn't enumerable
   var myObj = Object.create({}, {
     getFoo: {
       value: function () { return this.foo; }
     }
   });
   myObj.foo = 1;
   console.log(Object.keys(myObj)); // console: ['foo']
   ```
   
3. :book:参考

   > [(47条消息) js获取对象的属性个数_xufeiayang的博客-CSDN博客_js对象属性个数](https://blog.csdn.net/xufeiayang/article/details/80212841)

# 七、reduce()函数

1. ```javascript
   arr.reduce(callback(accumulator, currentValue[, index[, array]])[, initialValue])
   ```

2. 第一个参数：回调函数；第二个参数：累加的第一个参数

3. 数组为空，抛出TypeError错误

4. 写法一

   ```javascript
   const array1 = [1, 2, 3, 4];
   const reducer = (accumulator, currentValue) => accumulator + currentValue;
   
   // 1 + 2 + 3 + 4
   console.log(array1.reduce(reducer));
   // expected output: 10
   
   // 5 + 1 + 2 + 3 + 4
   console.log(array1.reduce(reducer, 5));
   // expected output: 15
   
   ```

5. 注意：累加对象数组，必须提供初始值

6. 计算数组中每个元素出现的次数

   ```javascript
   var names = ['Alice', 'Bob', 'Tiff', 'Bruce', 'Alice'];
   
   var countedNames = names.reduce(function (allNames, name) {
     if (name in allNames) {
       allNames[name]++;
     }
     else {
       allNames[name] = 1;
     }
     return allNames;
   }, {});
   // countedNames is:
   // { 'Alice': 2, 'Bob': 1, 'Tiff': 1, 'Bruce': 1 }
   ```

7. 按属性分类

   ```javascript
   var people = [
     { name: 'Alice', age: 21 },
     { name: 'Max', age: 20 },
     { name: 'Jane', age: 20 }
   ];
   
   function groupBy(objectArray, property) {
     return objectArray.reduce(function (acc, obj) {
       var key = obj[property];
       if (!acc[key]) {
         acc[key] = [];
       }
       acc[key].push(obj);
       return acc;
     }, {});
   }
   
   var groupedPeople = groupBy(people, 'age');
   // groupedPeople is:
   // {
   //   20: [
   //     { name: 'Max', age: 20 },
   //     { name: 'Jane', age: 20 }
   //   ],
   //   21: [{ name: 'Alice', age: 21 }]
   // }
   
   ```

# 八、【for-of】和【for-in】

1. for-of循环，主要用在部署了【Symbol.iterator属性】的数据结构，包括【数组、Set和Map结构】等等

2. 【forEach(element, index, originArray)】是数组的用法，for-of获取键值，for-in获取键名

3. for-of循环调用遍历器接口，只返回具有【数字索引】的属性

   ```javascript
   let arr = [3, 5, 7];
   arr.foo = 'hello';
    
   for (let i in arr) {
     console.log(i); // "0", "1", "2", "foo"
   }
    
   for (let i of arr) {
     console.log(i); //  "3", "5", "7"
   
   ```

4. map返回的是一个数组

   ```javascript
   let map = new Map().set('a', 1).set('b', 2);
   for (let pair of map) {
     console.log(pair);
   }
   // ['a', 1]
   // ['b', 2]
    
   for (let [key, value] of map) {
     console.log(key + ' : ' + value);
   }
   // a : 1
   // b : 2
   ```

5. 语法比较

   - for循环：书写麻烦
   - forEach循环：无法中途跳出
   - for-in循环：可以遍历键名，以及手动添加的其他键，甚至原型链上的键；某些情况下，遍历顺序不确定；:warning:主要适用于对象
   - for-of循环：和【for-in循环】一样简洁，可以搭配【break、continue】等使用，不能直接遍历对象，配合【Object.keys()】使用

# 九、!!，双感叹号

```javascript
let a = 1
let b = !!a				//	将a转换为布尔值，
```

1. :book:参考

   > [(24条消息) Javascript中!!(两个感叹号，双感叹号)的含义_谈谈IT-CSDN博客_js 两个感叹号](https://blog.csdn.net/tantanit/article/details/52287700)

# 十、from()函数

1. 语法

   ```javascript
   Array.from(arrayLike[, mapFn[, thisArg]])
   ```

   

2. 描述：从一个类似数组或可迭代对象创建新的、浅拷贝的数组实例

   ```javascript
   Array.from([1, 2, 3], x => x + x);
   // [2, 4, 6]
   ```

# 十一、concat()函数

1. 数组间的加法，返回新数组，不影响原数组，浅拷贝

# 十二、split()函数和join()函数

1. 将字符串变为数组

2. 分隔符为空，则返回单个字符组成数组；字符串和分隔符一样，则返回两个空字符串的数组；字符串和分隔符都为空，则返回空数组；字符串不存在分隔符，则返回长度为1，元素为字符串的数组

3. 颠倒数组

   ```javascript
   const str = 'asdfghjkl';
   const strReverse = str.split('').reverse().join(''); // 'lkjhgfdsa'
   ```

# 十三、正则表达式

1. 运行网页

   > [正则表达式在线测试 | 菜鸟工具 (runoob.com)](https://c.runoob.com/front-end/854/)

2. 常用

   - /-/g，匹配所有【-】字符

# 十四、JSON对象

1. JSON通常用于与服务端交换数据，数据格式为【字符串】

2. JSON.parse(param)：将包含【JSON格式】的字符串，转换为【标准JSON格式】

3. JSON.stringify(param)：将【JSON】对象，转换【字符串】

4. 案例：简单的【深拷贝】

   ```javascript
   let obj = { a: 1, b: { c: 2 } }
   let obj22 = JSON.parse(JSON.stringify(obj))
   obj.b.c = 33
   console.log('obj: ', obj)								//	{ a: 1, b: { c: 33 } }
   console.log('obj22: ', obj22)							//	{ a: 1, b: { c: 2 } }
   ```

5. :book:参考

   > [JSON.parse() | 菜鸟教程 (runoob.com)](https://www.runoob.com/json/json-parse.html)

# 十五、Vue框架

1. this.$set()语法格式

   - 功能：解决【数据变化时，视图没有变化】的问题

   - 写法：【this.$set()】和【Vue.set()】

   - 案例

     ```javascript
     items = [{
     		    name: 'hank',
     		    age: 12,
     		},
         	{
                 name: 'luna',
                 age: 13,
             }]
     //	改变变量
     this.items[0].name = 'zheng'
     //	等同于
     this.$set(this.items[0], 'name', 'zheng')
     //	一次改变多个
     this.item[0] = {name: 'zheng', age: 24}
     this.$set(this.items, 0, {name: 'zheng', age: 24})
     
     //	差别
     this.items[2] = {name: 'anna', age: 14}			//	数据改变，视图不改变
     this.$set(this.items, 2, {name: 'anna', age: 14})			//	数据改变，视图改变
     ```

   - :book:参考
   
     > [vue或uniapp中this.$set()时的语法格式（写法）_段龙龙博客 (duanlonglong.com)](http://www.duanlonglong.com/qdjy/953.html)

# 十六、进制转换

1. parseInt：解析字符串，指定进制，返回十进制整数

   ```javascript
   // 字符串，转十进制
   let number = '11'
   let one = parseInt(number, 8)
   let two = parseInt(number, 2)
   console.log(one);			// result:9
   console.log(two);			// result:3
   ```

2. toString：

# 十七、构造函数涉及的三种方法

1. 构造函数，实例方法，静态方法和原型方法区分

   ```javascript
   function Cat (name) {			//	构造函数Cat
       this.name = name			//	实例变量
       this.move = function () {	//	实例方法
           console.log('cat moves...')
       }
   }
   ```

2. 实例方法

   ```javascript
   Cat.eat = function () {			//	静态方法
       console.log('cat eats...')
   }
   Cat.eat()					//	静态方法，调用
   ```

   

3. 静态方法

   ```javascript
   function Cat (name) {
       this.name = name
       this.move = function () {
           console.log('cat moves...')
       }
   }
   let cat = new Cat('tom')	//	实例化，不是单例
   cat.move()					//	实例方法，调用
   ```

4. 原型方法

   ```javascript
   Cat.prototype.shout = function () {		//	原型方法，实例和构造函数都可以访问
       this.name = 'luna'					//	原型方法中，可以调用实例变量
       console.log('cat shouts...')
   }
   Cat.shout()					//	构造函数调用
   cat.shout()					//	实例调用
   ```


# 十八、findIndex()和find()函数

1. find(fn)函数会返回满足测试函数的第一个元素的值，没有则返回undefined

   ```javascript
   const array1 = [5, 12, 8, 130, 44];
   const found = array1.find(element => element > 10);
   console.log(found);					// expected output: 12
   
   ```

2. findIndex(fn)函数会返回满足测试函数的第一个元素的索引，没有则返回-1

   ```javascript
   const array1 = [5, 12, 8, 130, 44];
   const isLargeNumber = (element) => element > 13;
   console.log(array1.findIndex(isLargeNumber));			// expected output: 3
   ```

   

# 十九、String.fromCharCode()函数

1. 尝试

# 二十、单例——设计模式

1. 尝试

# 二十一、CommonJS和NodeJS模块化



1. NodeJS模块化

   - 基础了解：遵循【CommonJS】规范，实现了【一个文件是一个模块】，API关键字是【module.exports】和【require】

   - 模块分类

     1. 内置模块：NodeJS官方提供，【fs模块】文件读写，【path模块】路径，【http模块】网络请求

     2. 自定义模块：自定义模块，通过相对路径自行导入和导出

     3. 第三方模块：npm网站的模块，需要下载安装

        

   - 使用方法

     ```javascript
     function eat() {
         console.log('eat apples...')
     }
     //	方法一
     module.exports.eat = eat					//	导出
     const action = require('./file.js')			//	导入
     action.eat()							//	调用
     
     //	方法二
     exports.eat = eat							//	省略【module.】
     const action = require('./file')			//	省略【.js】
     action.eat()
     
     //	方法三
     module.exports = eat						//	省略【.eat】
     const action = require('./file')	
     action()									//	省略【.eat()】
     ```

     

2. js模块化：ES6中提出，实现【一个js文件引用另一个js文件】，API关键字是【import】和【export】

3. npm补充

   - 第三方模块，也成为【包】

   - 使用方法

     ```shell
     npm i packageName1 [packageName2]
     npm i packageName@1.0.0
     npm i init [-y]								//	有-y，则是快速新建【package.json】文件
     npm i										//	一次安装所有包，更新【node_module】文件夹
     npm uninstall packageName1
     
     npm config get registry						//	获取【镜像源】
     npm config set registry=https://www.baidu.com
     ```

   - dependencies节点：开发和上线都会用到的包

   - devDependecies节点：开发阶段会用到的包

     ```shell
     npm install packageName -D
     npm install packageName --save-dev
     ```

4. :book:参考

   > [node模块化 - 掘金 (juejin.cn)](https://juejin.cn/post/7015927054239531039)
   >
   > [npm关于package.json安装的那些事 - SegmentFault 思否](https://segmentfault.com/a/1190000017552119)

# 二十二、ES6函数参数解构

1. 对象缩写

   ```javascript
   const name = 'Hank'
   const person = {
       name
   }
   console.log(person.name)
   ```

2. 解构赋值

   ```javascript
   const person = {
       name: 'Hank'
   }
   const {name, age = 12} = person		//	也可以有默认值
   console.log(name, age)				//	结果是【Hank 12】
   ```

3. 函数的解构赋值运用

   ```javascript
   function sayName ({ firstName, lastName } = {}) {
       console.log(firstName + ' ' + lastName)
   }
   let person = {
       firstName: 'Hank',
       lastName: 'Zheng'
   }
   sayName(person)					//	结果是【Hank Zheng】
   
   //	提供默认值
   function sayName ({ firstName = 'foo', lastName = 'bar' } = {}) {
       console.log(firstName + ' ' + lastName)
   }
   let person = {
       firstName: 'Hank',
       lastName: 'Zheng'
   }
   sayName(person)					//	结果是【Hank Zheng】
   sayName()						//	结果是【foo bar】
   sayName({wrongName: 'Luna', lastName: 'Angel'})	//	结果是【foo, Angel】
   ```

4. :book:参考

   > ES6函数解构：[(48条消息) ES6函数参数解构_RUCwang的博客-CSDN博客_参数解构](https://blog.csdn.net/RUCwang/article/details/83002819)

# 二十三、Object.assign()函数

- 介绍：将【可枚举属性】从【一个或多个】源对象，分配到目标对象，并返回【目标对象】

  ```javascript
  const target = { a: 1, b: 2 }
  const source = { b: 4, c: 5 }
  
  const returnedTarget = Object.assign(target, source)
  
  console.log(target)									//	{ a: 1, b: 4, c: 5}
  console.log(returnedTarget)							//	{ a: 1, b: 4, c: 5}
  ```

- :warning:备注

  - 是【浅拷贝】
  - 相同的键，覆盖赋值

# 附：细节

1. 案例一，关于【空】等判断

   - 空的【字符串】、【对象】、【数组】、【0】以及【undefined】的细节

      ```javascript
      //	字符串
      let str = ''
      console.log(!!str)									//	false
      console.log(str == '')								//	true
      console.log(str == false)							//	true
      console.log(typeof str)								//	string
      
      //	数组
      let arr = []
      console.log(!![])									//	true
      console.log(arr == [])								//	false
      console.log(arr == '')								//	true
      console.log(arr == false)							//	true
      console.log(typeof arr)								//	object
      
      //	对象
      let obj = {}
      console.log(!!obj)									//	true
      console.log(obj == '')								//	false
      console.log(obj == [])								//	false
      console.log(obj == {})								//	false
      console.log(obj == false)							//	false
      console.log(obj == true)							//	false
      console.log(typeof obj)								//	object
      
      //	Number
      let num = 0
      console.log(!!0)									//	false
      console.log(num == false)							//	true
      console.log(num == '')								//	true
      console.log(num == [])								//	true
      console.log(num == {})								//	false
      console.log(num == 0)								//	true
      console.log(typeof num)								//	number
      
      //	undefined
      let charac = undefined
      console.log(!!undefined)							//	false
      console.log(!undefined)								//	true
      console.log(charac == true || charac == false)			//	false
      console.log(charac == undefined)						//	true
      console.log(charac == '' || [] || {})					//	false
      console.log(typeof charac)								//	undefined
      ```

   - 补充：关于【!!】符号的使用

     ```javascript
     console.log('!!2: ', !!2)							//	true，翻译成布尔值
     console.log('!!null: ', !!null)						//	false，翻译成布尔值
     ```

2. 案例二，简单的【深拷贝/Deep Clone】

   ```javascript
   let obj1 = { a: 0, b: { c: 0 } }
   let obj2 = JSON.parse(JSON.stringify(obj1))
   obj1.a = 4
   obj1.b.c = 4
   console.log(obj1)										//	{ a: 4, b: { c: 4 } }
   console.log(obj2)										//	{ a: 0, b: { c: 0 } }
   ```

   

